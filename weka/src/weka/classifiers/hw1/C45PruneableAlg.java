package weka.classifiers.hw1;

import java.util.LinkedList;
import java.util.List;

import junit.framework.Assert;
import weka.classifiers.Classifier;
import weka.classifiers.trees.j48.C45PruneableClassifierTree;
import weka.classifiers.trees.j48.ClassifierTree;
import weka.classifiers.trees.j48.ModelSelection;
import weka.core.Instance;
import weka.core.Instances;

public class C45PruneableAlg extends C45PruneableClassifierTree {
	/**
	 * serial auto generated by eclipse 
	 */
	private static final long serialVersionUID = -1127273110213749838L;
	private final boolean ignoreAttributes;
	public C45PruneableAlg(ModelSelection toSelectLocModel, boolean pruneTree,
			float cf, boolean raiseTree, boolean cleanup, boolean collapseTree, ClassifierFactory factory,boolean ignoreAttributes)
					throws Exception {
		super(toSelectLocModel, pruneTree, cf, raiseTree, cleanup, collapseTree);
		this.ignoreAttributes = ignoreAttributes;
		if (factory == null) throw new IllegalArgumentException("Must procide a non-null factory");
		this.factory = factory;	
	}

	private final List<Instance> instancesList = new LinkedList<Instance>();
	private Classifier leafClassifier = null;
	protected final ClassifierFactory factory;

	@Override
	protected ClassifierTree getNewTree(Instances data) throws Exception {

		ClassifierTree newTree = new TreeAlg(m_toSelectModel,factory,ignoreAttributes, m_pruneTheTree, m_CF, m_subtreeRaising, m_cleanup, m_collapseTheTree);
		newTree.buildTree(data, false);

		return newTree;
	}

	@Override
	protected ClassifierTree getNewTree(Instances train, Instances test)  throws Exception {
		ClassifierTree newTree = new TreeAlg(m_toSelectModel,factory,ignoreAttributes, m_pruneTheTree, m_CF, m_subtreeRaising, m_cleanup, m_collapseTheTree);
		newTree.buildTree(train, test, false);
		return newTree;
	}

	@Override
	public void buildClassifier(Instances data) throws Exception {
		super.buildClassifier(data);
		for (Instance instance : data) {
			Assert.assertEquals(0., //TODO: nocommit
					classifyInstance(instance) 
					); //TODO: nocommit
		}
		buildSecondClassifier(data);
	}

	@Override
	protected double handleLeaf(int classIndex, Instance instance, double weight)
			throws Exception {
		if (isAggregatingExamples()) { 
			instancesList.add(instance);
			return 0.;
		} else { 
			return weight * leafClassifier.classifyInstance(instance);
		}
	}

	private boolean isAggregatingExamples() {
		return leafClassifier == null;
	}

	private void buildSecondClassifier(Instances orig) throws Exception {
		if (m_isLeaf) {
			leafClassifier = factory.getClassifier();
			int numOfInstances = orig.size(); //TODO: nocommit
			Instances instances = new Instances(orig);
			instances.clear();
			Assert.assertEquals(orig.size(), numOfInstances); //TODO: no commit
			instances.addAll(instancesList);
			leafClassifier.buildClassifier(instances);
		}
		else { 
			//TODO: add mechanism that allows removing attributes that were used on the tree classifier from the other alg classifier.
			for (int i = 0; i < m_sons.length; i++) {
				((C45PruneableAlg)m_sons[i]).buildSecondClassifier(orig);
			}
		}

	}
}
